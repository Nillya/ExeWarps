--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Commands\CommandWarp.cs ---
﻿using System;
using System.Collections.Generic;
using System.Linq;
using Rocket.API;
using Rocket.Unturned.Chat;
using Rocket.Unturned.Player;
using UnityEngine;
using AdvancedWarps.Core;
using AdvancedWarps.Models;
using AdvancedWarps.Harmony;
using AdvancedWarps.Utilities;

namespace AdvancedWarps.Commands
{
    public class CommandWarp : IRocketCommand
    {
        public AllowedCaller AllowedCaller => AllowedCaller.Player;
        public string Name => "warp";
        public string Help => "Warp command for teleportation and management.";
        public string Syntax => "<list|add|adda|addpd|replace|rem|rempd> [warp_name] [second_warp_name/subwarp_id]";
        public List<string> Aliases => new List<string>();
        public List<string> Permissions => new List<string> { "warp" };

        public void Execute(IRocketPlayer caller, string[] command)
        {
            UnturnedPlayer player = (UnturnedPlayer)caller;
            PlayerComponent component = player.GetComponent<PlayerComponent>();

            if (command.Length == 0)
            {
                new Transelation("warp_null", Array.Empty<object>()).execute(player);
                return;
            }
            if (command[0].ToLower() == "list")
            {
                var activeWarps = Plugin.Instance.Configuration.Instance.Warps.Where(w => w.IsActive).OrderBy(w => w.WarpId).ToList();
                if (activeWarps.Count > 0)
                {
                    string warpList = player.IsAdmin
                        ? string.Join(", ", activeWarps.Select(w => $"[ID: {w.WarpId}] {w.Name}"))
                        : string.Join(", ", activeWarps.Select(w => w.Name));
                    UnturnedChat.Say(player, $"Available warps: {warpList}", Color.yellow);
                }
                else
                {
                    new Transelation("warp_list_empty", Array.Empty<object>()).execute(player);
                }

                if (player.IsAdmin && Plugin.Instance.Configuration.Instance.AdminWarps.Count > 0)
                {
                    string adminWarpList = string.Join(", ", Plugin.Instance.Configuration.Instance.AdminWarps.Select(w => w.Name));
                    UnturnedChat.Say(player, $"Admin warps: {adminWarpList}", Color.cyan);
                }
                return;
            }
            else if (command[0].ToLower() == "add" && command.Length >= 2 && player.IsAdmin)
            {
                string warpName = command[1];

                if (Plugin.Instance.Configuration.Instance.Warps.Any(w => w.Name != null && w.Name.ToLower() == warpName.ToLower()) ||
                    Plugin.Instance.Configuration.Instance.AdminWarps.Any(w => w.Name != null && w.Name.ToLower() == warpName.ToLower()))
                {
                    new Transelation("warp_exists", new object[] { warpName }).execute(player);
                    return;
                }

                Vector3 playerPosition = player.Position;
                Warp newWarp;

                if (Plugin.Instance.Configuration.Instance.AutoLocation)
                {
                    // Находим ближайшую известную локацию
                    KnownLocation nearestLocation = null;
                    float minDistance = float.MaxValue;
                    var knownLocations = KnownLocationsProvider.GetKnownLocations();

                    foreach (var location in knownLocations)
                    {
                        float distance = Vector3.Distance(playerPosition, (Vector3)location.Position);
                        if (distance < minDistance)
                        {
                            minDistance = distance;
                            nearestLocation = location;
                        }
                    }

                    if (nearestLocation == null)
                    {
                        new Transelation("warp_near_loc_null", Array.Empty<object>()).execute(player);
                        return;
                    }

                    // Проверяем, есть ли уже активный варп с таким WarpId
                    Warp existingWarp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.WarpId == nearestLocation.WarpId && w.IsActive);
                    if (existingWarp != null)
                    {
                        new Transelation("warp_already_at_location", new object[] { nearestLocation.Name }).execute(player);
                        return;
                    }

                    // Создаем новый варп с привязкой к известной локации
                    newWarp = new Warp(warpName, nearestLocation.WarpId);
                }
                else
                {
                    // Находим первый свободный WarpId
                    var existingWarpIds = Plugin.Instance.Configuration.Instance.Warps
                        .Where(w => w.IsActive)
                        .Select(w => w.WarpId)
                        .OrderBy(id => id)
                        .ToList();

                    int newWarpId = 1;
                    while (existingWarpIds.Contains(newWarpId))
                    {
                        newWarpId++;
                    }

                    // Создаем новый варп с первым свободным WarpId
                    newWarp = new Warp(warpName, newWarpId);
                }

                if (Plugin.Instance.Configuration.Instance.AddSubWarpOnCreate) 
                {
                    newWarp.SubWarps.Add(new SubWarp(1, new SerializableVector3(playerPosition.x, playerPosition.y, playerPosition.z)));
                }
                
                Plugin.Instance.Configuration.Instance.Warps.Add(newWarp);

                Plugin.Instance.Configuration.Save();
                new Transelation("warp_create_ok", new object[] { warpName }).execute(player);
            }
            else if (command[0].ToLower() == "adda" && command.Length >= 2 && player.IsAdmin)
            {
                string warpName = command[1];
                if (Plugin.Instance.Configuration.Instance.Warps.Any(w => w.Name != null && w.Name.ToLower() == warpName.ToLower()) ||
                    Plugin.Instance.Configuration.Instance.AdminWarps.Any(w => w.Name != null && w.Name.ToLower() == warpName.ToLower()))
                {
                    new Transelation("warp_exists", new object[] { warpName }).execute(player);
                    return;
                }

                AdminWarp newAdminWarp = new AdminWarp(warpName, new SerializableVector3(player.Position.x, player.Position.y, player.Position.z));
                Plugin.Instance.Configuration.Instance.AdminWarps.Add(newAdminWarp);
                Plugin.Instance.Configuration.Save();
                new Transelation("admin_warp_create_ok", new object[] { warpName }).execute(player);
            }
            else if (command[0].ToLower() == "addpd" && command.Length >= 2 && player.IsAdmin)
            {
                string warpName = command[1];
                Warp warp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.Name.ToLower() == warpName.ToLower());
                if (warp == null)
                {
                    new Transelation("warp_null", Array.Empty<object>()).execute(player);
                    return;
                }

                int newSubWarpId = warp.SubWarps.Count + 1;
                warp.SubWarps.Add(new SubWarp(newSubWarpId, new SerializableVector3(player.Position.x, player.Position.y, player.Position.z)));
                Plugin.Instance.Configuration.Save();
                new Transelation("warp_add_subwarp_ok", new object[] { warpName, newSubWarpId }).execute(player);
            }
            else if (command[0].ToLower() == "replace" && command.Length >= 3 && player.IsAdmin)
            {
                int id1, id2;
                bool isId1 = int.TryParse(command[1], out id1);
                bool isId2 = int.TryParse(command[2], out id2);

                // Find source warp
                Warp sourceWarp = null;
                if (isId1)
                {
                    sourceWarp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.WarpId == id1 && w.IsActive);
                }
                else
                {
                    sourceWarp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.Name != null && w.IsActive && w.Name.ToLower() == command[1].ToLower());
                }

                if (sourceWarp == null)
                {
                    new Transelation("warp_null", Array.Empty<object>()).execute(player);
                    return;
                }

                // Handle target based on whether it's an ID or name
                Warp targetWarp = null;
                int targetId = -1;

                if (isId2)
                {
                    targetId = id2;
                    if (targetId < 1 || targetId > 100) // Reasonable upper limit
                    {
                        new Transelation("invalid_position", Array.Empty<object>()).execute(player);
                        return;
                    }
                    targetWarp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.WarpId == targetId && w.IsActive);
                }
                else
                {
                    targetWarp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.Name != null && w.IsActive && w.Name.ToLower() == command[2].ToLower());
                    if (targetWarp == null)
                    {
                        new Transelation("warp_null", Array.Empty<object>()).execute(player);
                        return;
                    }
                }

                // Check if source and target are the same warp
                if (isId2 && sourceWarp.WarpId == targetId || !isId2 && sourceWarp == targetWarp)
                {
                    new Transelation("warp_same_swap", Array.Empty<object>()).execute(player);
                    return;
                }

                // Perform the replacement
                if (isId2)
                {
                    Warp existingWarp = targetWarp; // Может быть null, если ID свободен
                    if (existingWarp != null && existingWarp != sourceWarp)
                    {
                        // Swap IDs if the target ID is occupied
                        int tempId = sourceWarp.WarpId;
                        sourceWarp.WarpId = targetId;
                        existingWarp.WarpId = tempId;
                    }
                    else
                    {
                        // Just reassign the source warp's ID to the target ID
                        sourceWarp.WarpId = targetId;
                    }
                }
                else
                {
                    // Swap IDs between sourceWarp and targetWarp
                    int tempId = sourceWarp.WarpId;
                    sourceWarp.WarpId = targetWarp.WarpId;
                    targetWarp.WarpId = tempId;
                }

                // Sort the list by WarpId
                Plugin.Instance.Configuration.Instance.Warps.Sort((a, b) => a.WarpId.CompareTo(b.WarpId));

                Plugin.Instance.Configuration.Save();

                string identifier1 = isId1 ? id1.ToString() : command[1];
                string identifier2 = isId2 ? id2.ToString() : command[2];
                new Transelation("warp_replace_ok", new object[] { identifier1, identifier2 }).execute(player);
            }
            else if (command[0].ToLower() == "rem" && command.Length >= 2 && player.IsAdmin)
            {
                string warpName = command[1];
                Warp warp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.Name != null && w.Name.ToLower() == warpName.ToLower());
                AdminWarp adminWarp = Plugin.Instance.Configuration.Instance.AdminWarps.Find(w => w.Name.ToLower() == warpName.ToLower());

                if (warp != null)
                {
                    warp.Name = null; // Mark as inactive instead of removing
                    warp.SubWarps.Clear();
                    warp.IsActive = false;
                    Plugin.Instance.Configuration.Save();
                    new Transelation("warp_delete_ok", new object[] { warpName }).execute(player);
                }
                else if (adminWarp != null)
                {
                    Plugin.Instance.Configuration.Instance.AdminWarps.Remove(adminWarp);
                    Plugin.Instance.Configuration.Save();
                    new Transelation("admin_warp_delete_ok", new object[] { warpName }).execute(player);
                }
                else
                {
                    new Transelation("warp_null", Array.Empty<object>()).execute(player);
                }
            }
            else if (command[0].ToLower() == "rempd" && command.Length >= 3 && player.IsAdmin)
            {
                string warpName = command[1];
                Warp warp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.Name.ToLower() == warpName.ToLower());
                if (warp == null)
                {
                    new Transelation("warp_null", Array.Empty<object>()).execute(player);
                    return;
                }

                if (!int.TryParse(command[2], out int subWarpId) || subWarpId <= 0)
                {
                    new Transelation("invalid_subwarp_id", Array.Empty<object>()).execute(player);
                    return;
                }

                SubWarp subWarp = warp.SubWarps.Find(sw => sw.Id == subWarpId);
                if (subWarp == null)
                {
                    new Transelation("subwarp_not_found", new object[] { subWarpId }).execute(player);
                    return;
                }

                warp.SubWarps.Remove(subWarp);
                for (int i = 0; i < warp.SubWarps.Count; i++)
                {
                    warp.SubWarps[i].Id = i + 1;
                }

                Plugin.Instance.Configuration.Save();
                new Transelation("subwarp_delete_ok", new object[] { warpName, subWarpId }).execute(player);
            }
            else
            {
                string warpName = command[0];
                Warp warp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.Name != null && w.IsActive && w.Name.ToLower() == warpName.ToLower());
                AdminWarp adminWarp = Plugin.Instance.Configuration.Instance.AdminWarps.Find(w => w.Name.ToLower() == warpName.ToLower());

                if (adminWarp != null)
                {
                    if (!player.IsAdmin)
                    {
                        new Transelation("no_admin_access", Array.Empty<object>()).execute(player);
                        return;
                    }

                    player.Teleport((Vector3)adminWarp.Position, player.Rotation);
                    new Transelation("warp_successfully_teleported", Array.Empty<object>()).execute(player);
                }
                else if (warp != null && warp.SubWarps.Count > 0)
                {
                    if (Plugin.Instance.Warping.Contains(player.CSteamID))
                    {
                        new Transelation("already_delay", Array.Empty<object>()).execute(player);
                        return;
                    }

                    component.CurrentWarp = warp;
                    component.TimeTeleportWarp = DateTime.Now;
                    component.InitialPosition = new SerializableVector3(player.Position.x, player.Position.y, player.Position.z);
                    component.IsTeleporting = true;

                    Plugin.Instance.Warping.Add(player.CSteamID);
                    new Transelation("warp_teleport_ok", new object[] { warp.Name, Plugin.Instance.Configuration.Instance.DelayTeleportToWarp }).execute(player);
                }
                else
                {
                    new Transelation("warp_null", Array.Empty<object>()).execute(player);
                }
            }
        }
    }
}

--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Commands\CommandWarps.cs ---
﻿using Rocket.API;
using Rocket.Unturned.Player;
using SDG.Unturned;
using System.Collections.Generic;
using System.Linq;
using AdvancedWarps.Core;
using AdvancedWarps.Models;

namespace AdvancedWarps.Commands
{
    public class CommandWarps : IRocketCommand
    {
        public AllowedCaller AllowedCaller => AllowedCaller.Player;
        public string Name => "warps";
        public string Help => "Opens the warp selection UI.";
        public string Syntax => "";
        public List<string> Aliases => new List<string>();
        public List<string> Permissions => new List<string> { "warps" };

        public void Execute(IRocketPlayer caller, string[] command)
        {
            UnturnedPlayer player = (UnturnedPlayer)caller;

            // Enable Modal flag for blur and mouse freedom
            player.Player.enablePluginWidgetFlag(EPluginWidgetFlags.Modal);

            // Open UI with effect ID from configuration
            EffectManager.sendUIEffect((ushort)Plugin.Instance.Configuration.Instance.UIEffectID, short.MaxValue, player.Player.channel.owner.transportConnection, true);

            // Clear all UI slots first up to MaxWarpsInUI
            int maxSlots = Plugin.Instance.Configuration.Instance.MaxWarpsInUI;
            for (int i = 1; i <= maxSlots; i++)
            {
                EffectManager.sendUIEffectText(short.MaxValue, player.Player.channel.owner.transportConnection, true, $"Warp_loc_text_{i}", "");
            }

            // Fill UI slots with active warps
            var activeWarps = Plugin.Instance.Configuration.Instance.Warps.Where(w => w.IsActive).ToList();
            foreach (var warp in activeWarps)
            {
                int uiSlot = warp.WarpId; // Use WarpId as the UI slot
                if (uiSlot >= 1 && uiSlot <= maxSlots) // Ограничиваем количеством слотов из конфига
                {
                    EffectManager.sendUIEffectText(short.MaxValue, player.Player.channel.owner.transportConnection, true, $"Warp_loc_text_{uiSlot}", warp.Name);
                }
            }
        }
    }
}

--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Core\Configuration.cs ---
﻿using System.Collections.Generic;
using Rocket.API;
using AdvancedWarps.Models;
using AdvancedWarps.Commands;
using AdvancedWarps.Harmony;
using AdvancedWarps.Utilities;

namespace AdvancedWarps.Core
{
    public class Configuration : IDefaultable, IRocketPluginConfiguration
    {
        public int DelayTeleportToWarp;
        public bool CancelOnDamage;
        public bool CancelOnMovement;
        public float MovementCancelRadius;
        public bool CancelOnShooting;
        public float NoBuildRadius;
        public double WarpProtect;
        public bool AutoLocation;
        public bool AddSubWarpOnCreate;
        public int MaxWarpsInUI;
        public int UIEffectID;
        public bool DownloadWorkshop;
        public List<Warp> Warps;
        public List<AdminWarp> AdminWarps;

        public void LoadDefaults()
        {
            DelayTeleportToWarp = 3;
            CancelOnDamage = true;
            CancelOnMovement = true;
            MovementCancelRadius = 2f;
            CancelOnShooting = true;
            NoBuildRadius = 5f;
            WarpProtect = 4;
            AutoLocation = true;
            AddSubWarpOnCreate = true;
            MaxWarpsInUI = 10;
            UIEffectID = 45882;
            DownloadWorkshop = true;
            Warps = new List<Warp>();
            AdminWarps = new List<AdminWarp>();
        }
    }
}

--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Core\PlayerComponent.cs ---
﻿using Rocket.Unturned.Player;
using SDG.Unturned;
using UnityEngine;
using System;
using AdvancedWarps.Models;
using AdvancedWarps.Core;
using AdvancedWarps.Utilities;

namespace AdvancedWarps.Core
{
    public class PlayerComponent : UnturnedPlayerComponent
    {
        public Warp CurrentWarp = null;
        public DateTime TimeTeleportWarp = DateTime.Now;
        public SerializableVector3 InitialPosition;
        public bool IsTeleporting = false;

        public void CancelTeleport(string messageKey)
        {
            if (!string.IsNullOrEmpty(messageKey))
            {
                new Transelation(messageKey).execute(base.Player);
            }
            Plugin.Instance.Warping.Remove(base.Player.CSteamID);
            CurrentWarp = null;
            IsTeleporting = false;
        }

        public void FixedUpdate()
        {
            if (CurrentWarp == null || !IsTeleporting) { }
            else
            {
                // Отмена из-за движения
                if (Plugin.Instance.Configuration.Instance.CancelOnMovement)
                {
                    float distance = Vector3.Distance(base.Player.Position, (Vector3)InitialPosition);
                    if (distance > Plugin.Instance.Configuration.Instance.MovementCancelRadius)
                    {
                        CancelTeleport("warp_cancel_movement");
                        return;
                    }
                }

                // Завершение телепорта
                if ((DateTime.Now - TimeTeleportWarp).TotalSeconds >= Plugin.Instance.Configuration.Instance.DelayTeleportToWarp)
                {
                    if (CurrentWarp.SubWarps.Count > 0)
                    {
                        int randomIndex = UnityEngine.Random.Range(0, CurrentWarp.SubWarps.Count);
                        SubWarp subWarp = CurrentWarp.SubWarps[randomIndex];
                        base.Player.Teleport((Vector3)subWarp.Position, base.Player.Rotation);
                        new Transelation("warp_successfully_teleported").execute(base.Player);
                        Plugin.Instance.AfterWarp(base.Player);
                    }
                    CurrentWarp = null;
                    IsTeleporting = false;
                }
            }

            // Снятие защиты по времени
            if (Plugin.Instance._warpProtect.TryGetValue(base.Player.CSteamID, out DateTime protectEnd))
            {
                if (DateTime.Now >= protectEnd)
                {
                    Plugin.Instance.RemoveWarpProtect(base.Player.CSteamID, false);
                }
            }
        }
    }
}


--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Core\Plugin.cs ---
﻿using System;
using System.Collections.Generic;
using Rocket.API.Collections;
using Rocket.Core.Plugins;
using Rocket.Unturned;
using Rocket.Unturned.Events;
using Rocket.Unturned.Player;
using SDG.Unturned;
using Steamworks;
using UnityEngine;
using HarmonyLib;
using AdvancedWarps.Models;
using AdvancedWarps.Commands;
using AdvancedWarps.Harmony;
using AdvancedWarps.Utilities;
using static Rocket.Unturned.Events.UnturnedPlayerEvents;
using System.ComponentModel;

namespace AdvancedWarps.Core
{
    public class Plugin : RocketPlugin<Configuration>
    {
        public static Plugin Instance;
        public List<CSteamID> Warping;
        internal Dictionary<CSteamID, DateTime> _warpProtect;
        private Dictionary<CSteamID, DateTime> _lastProtectMessage;

        public override TranslationList DefaultTranslations
        {
            get
            {
                TranslationList translationList = new TranslationList();
                translationList.Add("warp_null", "Warp with this name not found. Color=red");
                translationList.Add("warp_teleport_ok", "You will be teleported to warp: [{0}] in: [{1}sec]. Color=yellow");
                translationList.Add("warp_successfully_teleported", "You have been successfully teleported to the warp. Color=yellow");
                translationList.Add("warp_create_ok", "You have successfully created a warp named: [{0}]. Color=yellow");
                translationList.Add("warp_delete_ok", "You have successfully deleted the warp named: [{0}]. Color=yellow");
                translationList.Add("warp_replace_ok", "Warps [{0}] and [{1}] have been successfully swapped. Color=yellow");
                translationList.Add("warp_add_subwarp_ok", "Sub-warp added to warp [{0}] with ID: [{1}]. Color=yellow");
                translationList.Add("warp_cancel_damage", "Teleportation canceled due to damage. Color=red");
                translationList.Add("warp_cancel_movement", "Teleportation canceled due to movement. Color=red");
                translationList.Add("warp_cancel_shooting", "Teleportation canceled due to shooting. Color=red");
                translationList.Add("warp_cancel_melee", "Teleportation canceled due to melee attack. Color=red");
                translationList.Add("warp_cancel_throwable", "Teleportation canceled due to throwing. Color=red");
                translationList.Add("warp_cancel_punch", "Teleportation canceled due to punch. Color=red");
                translationList.Add("warp_cancel_disconnect", "Teleportation canceled due to disconnection. Color=red");
                translationList.Add("warp_cancel_death", "Teleportation canceled due to death. Color=red");
                translationList.Add("already_delay", "You are already waiting to be warped. Color=red");
                translationList.Add("build_restricted", "Building is prohibited near warps! Color=red");
                translationList.Add("invalid_subwarp_id", "Invalid sub-warp ID! Color=red");
                translationList.Add("subwarp_not_found", "Sub-warp with ID [{0}] not found! Color=red");
                translationList.Add("subwarp_delete_ok", "Sub-warp with ID [{1}] removed from warp [{0}]. Color=yellow");
                translationList.Add("warp_same_swap", "Cannot swap a warp with itself! Color=red");
                translationList.Add("invalid_position", "Invalid position specified! Color=red");
                translationList.Add("admin_warp_create_ok", "Admin warp [{0}] created successfully. Color=yellow");
                translationList.Add("admin_warp_delete_ok", "Admin warp [{0}] deleted successfully. Color=yellow");
                translationList.Add("no_admin_access", "Only admins can teleport to this warp! Color=red");
                translationList.Add("warp_exists", "Warp [{0}] already exists! Color=red");
                translationList.Add("warp_list_header", "Available warps: Color=yellow");
                translationList.Add("warp_list_empty", "No warps available. Color=red");
                translationList.Add("admin_warp_list_header", "Admin warps: Color=cyan");
                translationList.Add("warp_already_at_location", "A warp already exists at location [{0}]! Color=red");
                translationList.Add("warp_near_loc_null", "Warp location not found. Color=red");
                translationList.Add("warp_protect_active", "Player is under warp protection for [{0}] more seconds and cannot be damaged. Color=red");
                translationList.Add("warp_protect_expired", "Your warp protection has expired. Color=yellow");
                translationList.Add("warp_protect_removed_by_shooting", "Warp protection removed due to attack. Color=red");
                return translationList;
            }
        }

        protected override void Load()
        {
            Instance = this;
            Warping = new List<CSteamID>();
            _warpProtect = new Dictionary<CSteamID, DateTime>();
            _lastProtectMessage = new Dictionary<CSteamID, DateTime>();
            if (Configuration.Instance.DownloadWorkshop)
            {
                var workshopConfig = WorkshopDownloadConfig.getOrLoad();
                if (!workshopConfig.File_IDs.Contains(3456118035))
                {
                    workshopConfig.File_IDs.Add(3456118035);
                }
            }
            var harmony = new HarmonyLib.Harmony("com.warps.exe");
            harmony.PatchAll();
            U.Events.OnPlayerDisconnected += EventsOnPlayerDisconnected;
            UnturnedPlayerEvents.OnPlayerDeath += OnPlayerDeath;
            UnturnedPlayerEvents.OnPlayerUpdateGesture += OnPlayerUpdateGesture;
            BarricadeManager.onDeployBarricadeRequested = (DeployBarricadeRequestHandler)Delegate.Combine(BarricadeManager.onDeployBarricadeRequested, new DeployBarricadeRequestHandler(OnDeployBarricadeRequested));
            StructureManager.onDeployStructureRequested = (DeployStructureRequestHandler)Delegate.Combine(StructureManager.onDeployStructureRequested, new DeployStructureRequestHandler(OnDeployStructureRequested));
            DamageTool.damagePlayerRequested += DamageToolOnDamagePlayerRequested;
            EffectManager.onEffectButtonClicked += OnEffectButtonClicked;
        }

        protected override void Unload()
        {
            U.Events.OnPlayerDisconnected -= EventsOnPlayerDisconnected;
            UnturnedPlayerEvents.OnPlayerDeath -= OnPlayerDeath;
            UnturnedPlayerEvents.OnPlayerUpdateGesture -= OnPlayerUpdateGesture;
            BarricadeManager.onDeployBarricadeRequested = (DeployBarricadeRequestHandler)Delegate.Remove(BarricadeManager.onDeployBarricadeRequested, new DeployBarricadeRequestHandler(OnDeployBarricadeRequested));
            StructureManager.onDeployStructureRequested = (DeployStructureRequestHandler)Delegate.Remove(StructureManager.onDeployStructureRequested, new DeployStructureRequestHandler(OnDeployStructureRequested));
            DamageTool.damagePlayerRequested -= DamageToolOnDamagePlayerRequested;
            EffectManager.onEffectButtonClicked -= OnEffectButtonClicked;
            var harmony = new HarmonyLib.Harmony("com.warps.exe");
            harmony.UnpatchAll("com.warps.exe");
        }

        private void OnPlayerDeath(UnturnedPlayer player, EDeathCause cause, ELimb limb, CSteamID murderer)
        {
            var component = player.GetComponent<PlayerComponent>();
            if (component != null && component.IsTeleporting)
            {
                component.CancelTeleport("warp_cancel_death");
            }
        }

        public static readonly List<KnownLocation> KnownLocations = new List<KnownLocation>
        {
            new KnownLocation("Summerside Military Base", new SerializableVector3(0, 0, 0), 1),
            new KnownLocation("Stratford", new SerializableVector3(0, 0, 0), 2),
            new KnownLocation("Alberton", new SerializableVector3(0, 0, 0), 3),
            new KnownLocation("Belfast Airport", new SerializableVector3(0, 0, 0), 4),
            new KnownLocation("Cape Rock", new SerializableVector3(0, 0, 0), 5),
            new KnownLocation("Charlottetown", new SerializableVector3(0, 0, 0), 6),
            new KnownLocation("Confederation Bridge", new SerializableVector3(0, 0, 0), 7),
            new KnownLocation("Courtin Isle", new SerializableVector3(0, 0, 0), 8),
            new KnownLocation("Fernwood Farm", new SerializableVector3(0, 0, 0), 9),
            new KnownLocation("Holman Isle", new SerializableVector3(0, 0, 0), 10)
        };

        private void OnEffectButtonClicked(Player player, string buttonName)
        {
            UnturnedPlayer unturnedPlayer = UnturnedPlayer.FromPlayer(player);
            PlayerComponent component = unturnedPlayer.GetComponent<PlayerComponent>();

            if (buttonName.StartsWith("Warp_loc_"))
            {
                int warpId;
                if (int.TryParse(buttonName.Replace("Warp_loc_", ""), out warpId))
                {
                    // Find warp by WarpId instead of index
                    Warp warp = Plugin.Instance.Configuration.Instance.Warps.Find(w => w.WarpId == warpId && w.IsActive);
                    if (warp != null)
                    {
                        if (warp.SubWarps.Count == 0)
                        {
                            new Transelation("warp_null", Array.Empty<object>()).execute(unturnedPlayer);
                            return;
                        }

                        if (Plugin.Instance.Warping.Contains(unturnedPlayer.CSteamID))
                        {
                            new Transelation("already_delay", Array.Empty<object>()).execute(unturnedPlayer);
                            return;
                        }

                        component.CurrentWarp = warp;
                        component.TimeTeleportWarp = DateTime.Now;
                        component.InitialPosition = new SerializableVector3(unturnedPlayer.Position.x, unturnedPlayer.Position.y, unturnedPlayer.Position.z);
                        component.IsTeleporting = true;

                        Plugin.Instance.Warping.Add(unturnedPlayer.CSteamID);
                        new Transelation("warp_teleport_ok", new object[] { warp.Name, Plugin.Instance.Configuration.Instance.DelayTeleportToWarp }).execute(unturnedPlayer);

                        // Используем UIEffectID из конфига с приведением к ushort
                        EffectManager.askEffectClearByID((ushort)Plugin.Instance.Configuration.Instance.UIEffectID, unturnedPlayer.Player.channel.owner.transportConnection);
                        unturnedPlayer.Player.setPluginWidgetFlag(EPluginWidgetFlags.Modal, false);
                    }
                }
            }
            else if (buttonName == "Close_warp")
            {
                // Используем UIEffectID из конфига с приведением к ushort
                EffectManager.askEffectClearByID((ushort)Plugin.Instance.Configuration.Instance.UIEffectID, unturnedPlayer.Player.channel.owner.transportConnection);
                unturnedPlayer.Player.setPluginWidgetFlag(EPluginWidgetFlags.Modal, false);
            }
        }
        private void OnPlayerUpdateGesture(UnturnedPlayer player, PlayerGesture gesture)
        {
            if (gesture != PlayerGesture.PunchLeft && gesture != PlayerGesture.PunchRight) return;
            if (Plugin.Instance == null) return;

            Plugin.Instance.RemoveWarpProtect(player.CSteamID);

            PlayerComponent component = player.GetComponent<PlayerComponent>();
            if (component != null && component.IsTeleporting && Configuration.Instance.CancelOnShooting)
            {
                component.CancelTeleport("warp_cancel_punch");
            }
        }

        private void EventsOnPlayerDisconnected(UnturnedPlayer player)
        {
            if (Warping.Contains(player.CSteamID))
            {
                Warping.Remove(player.CSteamID);
                var component = player.GetComponent<PlayerComponent>();
                if (component != null && component.IsTeleporting)
                {
                    component.CancelTeleport("warp_cancel_disconnect");
                }
            }
        }

        private void OnDeployBarricadeRequested(Barricade barricade, ItemBarricadeAsset asset, Transform hit, ref Vector3 point, ref float angle_x, ref float angle_y, ref float angle_z, ref ulong owner, ref ulong group, ref bool shouldAllow)
        {
            if (shouldAllow)
            {
                foreach (var warp in Configuration.Instance.Warps)
                {
                    foreach (var subWarp in warp.SubWarps)
                    {
                        if (Vector3.Distance((Vector3)subWarp.Position, point) <= Configuration.Instance.NoBuildRadius)
                        {
                            shouldAllow = false;
                            UnturnedPlayer player = UnturnedPlayer.FromCSteamID(new CSteamID(owner));
                            if (player != null)
                            {
                                new Transelation("build_restricted", Array.Empty<object>()).execute(player);
                            }
                            return;
                        }
                    }
                }
            }
        }

        private void OnDeployStructureRequested(Structure structure, ItemStructureAsset asset, ref Vector3 point, ref float angle_x, ref float angle_y, ref float angle_z, ref ulong owner, ref ulong group, ref bool shouldAllow)
        {
            if (shouldAllow)
            {
                foreach (var warp in Configuration.Instance.Warps)
                {
                    foreach (var subWarp in warp.SubWarps)
                    {
                        if (Vector3.Distance((Vector3)subWarp.Position, point) <= Configuration.Instance.NoBuildRadius)
                        {
                            shouldAllow = false;
                            UnturnedPlayer player = UnturnedPlayer.FromCSteamID(new CSteamID(owner));
                            if (player != null)
                            {
                                new Transelation("build_restricted", Array.Empty<object>()).execute(player);
                            }
                            return;
                        }
                    }
                }
            }
        }

        private void DamageToolOnDamagePlayerRequested(ref DamagePlayerParameters parameters, ref bool shouldAllow)
        {
            CSteamID steamID = parameters.player.channel.owner.playerID.steamID;
            var player = UnturnedPlayer.FromCSteamID(steamID);
            var component = player.GetComponent<PlayerComponent>();

            if (component != null && component.IsTeleporting && Configuration.Instance.CancelOnDamage)
            {
                component.CancelTeleport("warp_cancel_damage");
            }

            if (shouldAllow && _warpProtect.ContainsKey(steamID) && _warpProtect[steamID] > DateTime.Now)
            {
                shouldAllow = false;
                // Send protection message with remaining time and rate limiting
                if (!_lastProtectMessage.ContainsKey(steamID) || (DateTime.Now - _lastProtectMessage[steamID]).TotalSeconds >= 1)
                {
                    UnturnedPlayer attacker = UnturnedPlayer.FromCSteamID(parameters.killer);
                    if (attacker != null)
                    {
                        // Calculate remaining time in seconds
                        double remainingSeconds = (_warpProtect[steamID] - DateTime.Now).TotalSeconds;
                        // Round to nearest second for readability
                        int roundedSeconds = (int)Math.Round(remainingSeconds);
                        new Transelation("warp_protect_active", new object[] { roundedSeconds }).execute(attacker);
                    }
                    _lastProtectMessage[steamID] = DateTime.Now;
                }
            }
        }

        //private void OnTriggerSend(SteamPlayer player, string s, ESteamCall mode, ESteamPacket type, object[] arguments)
        //{
        //    if (s != "tellEquip" || !_warpProtect.ContainsKey(player.playerID.steamID) || _warpProtect[player.playerID.steamID] < DateTime.Now)
        //    {
        //        return;
        //    }

        //    byte b = (byte)arguments[3];
        //    if (Assets.find(EAssetType.ITEM, (ushort)b) is ItemGunAsset)
        //    {
        //        _warpProtect.Remove(player.playerID.steamID);
        //    }
        //}
        //private void OnUseableUsed(PlayerEquipment equipment, Useable useable)
        //{
        //    var player = UnturnedPlayer.FromPlayer(equipment.player);
        //    if (player == null) return;

        //    // Проверяем, является ли используемый предмет оружием
        //    if (equipment.asset is ItemWeaponAsset)
        //    {
        //        if (_warpProtect.ContainsKey(player.CSteamID))
        //        {
        //            _warpProtect.Remove(player.CSteamID);
        //        }
        //    }
        //}

        public void RemoveWarpProtect(CSteamID playerId, bool byPlayerAction = false)
        {
            if (_warpProtect.ContainsKey(playerId))
            {
                var player = UnturnedPlayer.FromCSteamID(playerId);
                if (player != null)
                {
                    string key = byPlayerAction ? "warp_protect_removed_by_shooting" : "warp_protect_expired";
                    new Transelation(key, Array.Empty<object>()).execute(player);
                }
                _warpProtect.Remove(playerId);
                _lastProtectMessage.Remove(playerId);
            }
        }


        public void AfterWarp(UnturnedPlayer player)
        {
            Warping.Remove(player.CSteamID);
            _warpProtect[player.CSteamID] = DateTime.Now.AddSeconds(Configuration.Instance.WarpProtect);
        }
    }
}

--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Harmony\GunPatch.cs ---
﻿using HarmonyLib;
using Rocket.Unturned.Player;
using SDG.Unturned;
using AdvancedWarps.Core;

namespace AdvancedWarps.Harmony
{
    [HarmonyPatch(typeof(UseableGun), "shoot")]
    public class GunPatch
    {
        static void Prefix(UseableGun __instance)
        {
            if (__instance == null || __instance.player == null) return;

            var player = UnturnedPlayer.FromPlayer(__instance.player);
            if (player == null) return;

            var component = player.GetComponent<PlayerComponent>();

            // Снимаем защиту
            Plugin.Instance.RemoveWarpProtect(player.CSteamID, true);

            // Отменяем телепорт при включённой настройке
            if (component != null && component.IsTeleporting && Plugin.Instance.Configuration.Instance.CancelOnShooting)
            {
                component.CancelTeleport("warp_cancel_shooting");
            }
        }
    }
}


--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Harmony\MeleePatch.cs ---
﻿using HarmonyLib;
using Rocket.Unturned.Player;
using SDG.Unturned;
using AdvancedWarps.Core;
using AdvancedWarps.Models;
using AdvancedWarps.Commands;
using AdvancedWarps.Utilities;

namespace AdvancedWarps.Harmony
{
    [HarmonyPatch(typeof(UseableMelee), "fire")]
    public class MeleePatch
    {
        static void Prefix(UseableMelee __instance)
        {
            if (__instance.player == null) return;

            var player = __instance.player;
            var unturnedPlayer = UnturnedPlayer.FromPlayer(player);

            // Снятие WarpProtect при ударе холодным оружием
            Plugin.Instance.RemoveWarpProtect(unturnedPlayer.CSteamID);
        }
    }
}

--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Harmony\ThrowablePatch.cs ---
﻿using HarmonyLib;
using Rocket.Unturned.Player;
using SDG.Unturned;
using AdvancedWarps.Core;

namespace AdvancedWarps.Harmony
{
    [HarmonyPatch(typeof(UseableThrowable), "throwItem")]
    public class ThrowablePatch
    {
        static void Prefix(UseableThrowable __instance)
        {
            if (__instance == null || __instance.player == null)
                return;

            var player = UnturnedPlayer.FromPlayer(__instance.player);
            if (player == null)
                return;

            var component = player.GetComponent<PlayerComponent>();

            // Снимаем защиту
            Plugin.Instance.RemoveWarpProtect(player.CSteamID, true);

            // Отменяем телепорт при включённой опции
            if (component != null && component.IsTeleporting && Plugin.Instance.Configuration.Instance.CancelOnShooting)
            {
                component.CancelTeleport("warp_cancel_throwable");
            }
        }
    }
}


--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Models\KnownLocation.cs ---
﻿using System.Collections.Generic;
using Rocket.API;
using AdvancedWarps.Core;
using AdvancedWarps.Commands;
using AdvancedWarps.Harmony;
using AdvancedWarps.Utilities;

namespace AdvancedWarps.Models
{
    public class KnownLocation
    {
        public string Name { get; set; }
        public SerializableVector3 Position { get; set; }
        public int WarpId { get; set; }

        public KnownLocation(string name, SerializableVector3 position, int warpId)
        {
            Name = name;
            Position = position;
            WarpId = warpId;
        }
    }
}

--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Models\SerializableVector3.cs ---
﻿using System.Xml.Serialization;
using AdvancedWarps.Core;
using AdvancedWarps.Commands;
using AdvancedWarps.Harmony;
using AdvancedWarps.Utilities;

namespace AdvancedWarps.Models
{
    [XmlRoot("SerializableVector3")]
    public class SerializableVector3
    {
        [XmlAttribute("x")]
        public float X { get; set; }

        [XmlAttribute("y")]
        public float Y { get; set; }

        [XmlAttribute("z")]
        public float Z { get; set; }

        public SerializableVector3()
        {
            X = 0f;
            Y = 0f;
            Z = 0f;
        }

        public SerializableVector3(float x, float y, float z)
        {
            X = x;
            Y = y;
            Z = z;
        }

        public static implicit operator UnityEngine.Vector3(SerializableVector3 vec)
        {
            return new UnityEngine.Vector3(vec.X, vec.Y, vec.Z);
        }

        public static implicit operator SerializableVector3(UnityEngine.Vector3 vec)
        {
            return new SerializableVector3(vec.x, vec.y, vec.z);
        }
    }
}

--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Models\Warp.cs ---
﻿using System.Collections.Generic;
using System.Xml.Serialization;
using UnityEngine;
using AdvancedWarps.Core;
using AdvancedWarps.Commands;
using AdvancedWarps.Harmony;
using AdvancedWarps.Utilities;

namespace AdvancedWarps.Models
{
    public class Warp
    {
        [XmlAttribute]
        public string Name;

        [XmlAttribute]
        public int WarpId;

        [XmlAttribute]
        public bool IsActive = true;

        public List<SubWarp> SubWarps;

        public Warp(string name, int warpId)
        {
            this.Name = name;
            this.WarpId = warpId;
            this.SubWarps = new List<SubWarp>();
            this.IsActive = true;
        }

        public Warp()
        {
            this.SubWarps = new List<SubWarp>();
            this.IsActive = false;
        }
    }
    public class SubWarp
    {
        public int Id;
        public SerializableVector3 Position;

        public SubWarp(int id, SerializableVector3 position)
        {
            this.Id = id;
            this.Position = position;
        }

        public SubWarp()
        {
            this.Position = new SerializableVector3();
        }
    }
    public class AdminWarp
    {
        [XmlAttribute]
        public string Name;

        public SerializableVector3 Position;

        public AdminWarp(string name, SerializableVector3 position)
        {
            this.Name = name;
            this.Position = position;
        }

        public AdminWarp()
        {
            this.Position = new SerializableVector3();
        }
    }
}

--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\obj\Debug\.NETFramework,Version=v4.8.AssemblyAttributes.cs ---
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]


--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\obj\Debug\TemporaryGeneratedFile_036C0B5B-1481-4323-8D20-8F5ADCB23D92.cs ---


--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\obj\Debug\TemporaryGeneratedFile_5937a670-0e60-4077-877b-f7221da3dda1.cs ---


--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\obj\Debug\TemporaryGeneratedFile_E7A71F73-0F8D-4B9B-B56E-8E70B10BC5D3.cs ---


--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Properties\AssemblyInfo.cs ---
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyCompany("ExeWarps")]
[assembly: AssemblyConfiguration("Release")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyInformationalVersion("1.0.0")]
[assembly: AssemblyProduct("ExeWarps")]
[assembly: AssemblyTitle("Nillya")]
[assembly: AssemblyVersion("1.0.0.0")]


--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Utilities\KnownLocationsProvider.cs ---
﻿using System.Collections.Generic;
using AdvancedWarps.Core;
using AdvancedWarps.Models;
using AdvancedWarps.Commands;
using AdvancedWarps.Harmony;

namespace AdvancedWarps.Utilities
{
    public static class KnownLocationsProvider
    {
        public static List<KnownLocation> GetKnownLocations()
        {
            return new List<KnownLocation>
            {
                // Локации с предоставленными координатами
                new KnownLocation("Summerside Military Base", new SerializableVector3(-462.136f, 36.2897f, 686.4271f), 1),
                new KnownLocation("Stratford", new SerializableVector3(-76.6875f, 38.60232f, 643.3672f), 2),
                new KnownLocation("Alberton", new SerializableVector3(-554.960938f, 33.57555f, 160.367188f), 3),
                new KnownLocation("O'Leary Prison", new SerializableVector3(-244.96875f, 44.00486f, 14.828125f), 4),
                new KnownLocation("Charlottetown", new SerializableVector3(16.3046875f, 33.8957367f, -447.476563f), 5),
                new KnownLocation("Holman Isle", new SerializableVector3(-743.1719f, 55.1531219f, -766.3828f), 6),
                new KnownLocation("Tignish Farm", new SerializableVector3(547.726563f, 38.39512f, -747.1172f), 7),
                new KnownLocation("Montague", new SerializableVector3(295.3047f, 34.1097946f, -75.07031f), 8),
                new KnownLocation("Courtin Isle", new SerializableVector3(826.726563f, 47.8821335f, 134.679688f), 9),
                new KnownLocation("Belfast Airport", new SerializableVector3(727.085938f, 34.3646622f, 674.03125f), 10),

                // Оставшиеся локации из полного списка с нулевыми координатами
                //new KnownLocation("Cape Rock", new SerializableVector3(0, 0, 0), 11),
                //new KnownLocation("Confederation Bridge", new SerializableVector3(0, 0, 0), 12),
                //new KnownLocation("Fernwood Farm", new SerializableVector3(0, 0, 0), 13),
                //new KnownLocation("Kensington Campground", new SerializableVector3(0, 0, 0), 14),
                //new KnownLocation("Liberation Bridge", new SerializableVector3(0, 0, 0), 15),
                //new KnownLocation("Oulton's Isle", new SerializableVector3(0, 0, 0), 16),
                //new KnownLocation("Pirate Cove", new SerializableVector3(0, 0, 0), 17),
                //new KnownLocation("Souris Campground", new SerializableVector3(0, 0, 0), 18),
                //new KnownLocation("Taylor Beach", new SerializableVector3(0, 0, 0), 19),
                //new KnownLocation("Wellington Farm", new SerializableVector3(0, 0, 0), 20),
                //new KnownLocation("Wiltshire Farm", new SerializableVector3(0, 0, 0), 21)
            };
        }
    }
}

--- D:\Desktop files--------------------\----\Unturned----------\Сервер\PLG\MY\Joskiye ne moi\ExeWarps\ExeWarps net 4.5\ExeWarps\Utilities\Transelation.cs ---
﻿using Rocket.Core.Plugins;
using Rocket.Unturned.Chat;
using Rocket.Unturned.Player;
using SDG.Unturned;
using UnityEngine;
using AdvancedWarps.Core;
using AdvancedWarps.Models;
using AdvancedWarps.Commands;
using AdvancedWarps.Harmony;

namespace AdvancedWarps.Utilities
{
    public class Transelation
    {
        private Color _color;
        private string _message;
        private string _transelation;
        private readonly RocketPlugin _plugin;

        public Transelation(string transelation, params object[] args)
        {
            this._transelation = transelation;
            this._plugin = Plugin.Instance;
            this.refreshMessage(transelation, args);
        }

        public void refreshMessage(string trans, params object[] args)
        {
            string text = this.plugin.Translate(trans, args);
            try
            {
                int num = text.ToLower().LastIndexOf("color=");
                string text2 = text.Substring(num + 6);
                string text3 = text2;
                bool flag = text2.StartsWith("#");
                if (flag)
                {
                    text2 = text2.Remove(0, 1);
                }
                bool flag2 = !text3.StartsWith("#");
                if (flag2)
                {
                    text3 = text3.Insert(0, "#");
                }
                text = text.Remove(num);
                bool flag3 = ColorUtility.TryParseHtmlString(text3, out this._color);
                if (!flag3)
                {
                    this._color = UnturnedChat.GetColorFromName(text2, Color.green);
                }
            }
            catch
            {
                this._color = Color.green;
            }
            this._message = text;
        }

        public void execute(Player player)
        {
            UnturnedChat.Say(UnturnedPlayer.FromPlayer(player), this._message, this._color);
        }

        public void execute(UnturnedPlayer player)
        {
            UnturnedChat.Say(player, this._message, this._color);
        }

        public void execute()
        {
            UnturnedChat.Say(this._message, this._color);
        }

        public RocketPlugin plugin => this._plugin;
        public Color color => this._color;
        public string message => this._message;
        public string transelation => this._transelation;
    }
}

